/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: RasFCSMavlink.xml

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;


using System.Reflection;

namespace MavLink
{

    /// <summary>
    /// FlightSTATUS
    /// </summary>
    public enum FlightSTATUS : uint
    {

        /// <summary>
        /// Connected
        /// </summary>
        Connected = 0,

        /// <summary>
        /// Idle
        /// </summary>
        Idle = 1,

        /// <summary>
        /// Taxi
        /// </summary>
        Taxi = 2,

        /// <summary>
        /// Standby
        /// </summary>
        Standby = 3,

        /// <summary>
        /// RollOut
        /// </summary>
        RollOut = 4,

        /// <summary>
        /// Climb
        /// </summary>
        Climb = 5,

        /// <summary>
        /// Cruise
        /// </summary>
        Cruise = 6,

        /// <summary>
        /// Descend
        /// </summary>
        Descend = 7,

        /// <summary>
        /// Approach
        /// </summary>
        Approach = 8,

        /// <summary>
        /// Unkonwn
        /// </summary>
        Unkonwn = 9,
        FlightSTATUS_ENUM_END = 10,

    }


    /// <summary>
    /// ContrlMode
    /// </summary>
    public enum ContrlMode : uint
    {

        /// <summary>
        /// Manual
        /// </summary>
        Manual = 0,

        /// <summary>
        /// LateralNavigation
        /// </summary>
        LateralNavigation = 1,

        /// <summary>
        /// VerticalNavigation
        /// </summary>
        VerticalNavigation = 2,

        /// <summary>
        /// APOn
        /// </summary>
        APOn = 3,
        ContrlMode_ENUM_END = 4,

    }


    /// <summary>
    /// SpeedMode
    /// </summary>
    public enum SpeedMode : uint
    {

        /// <summary>
        /// ManualSpeed
        /// </summary>
        ManualSpeed = 0,

        /// <summary>
        /// AutoSpeed
        /// </summary>
        AutoSpeed = 1,
        SpeedMode_ENUM_END = 2,

    }


    /// <summary>
    /// FunctionStatus
    /// </summary>
    public enum FunctionStatus : uint
    {

        /// <summary>
        /// Online
        /// </summary>
        Online = 0,

        /// <summary>
        /// Offline
        /// </summary>
        Offline = 1,

        /// <summary>
        /// Failure
        /// </summary>
        Failure = 2,
        FunctionStatus_ENUM_END = 3,

    }


    /// <summary>
    /// LogType
    /// </summary>
    public enum LogType : uint
    {

        /// <summary>
        /// Debug
        /// </summary>
        Debug = 0,

        /// <summary>
        /// Warning
        /// </summary>
        Warning = 1,

        /// <summary>
        /// Error
        /// </summary>
        Error = 2,
        LogType_ENUM_END = 3,

    }


}



namespace MavLink
{

    public abstract class MavlinkMessage
    {
        public abstract int Serialize(byte[] bytes, ref int offset);
    }

    /// <summary>
    /// HEARTBEAT
    /// </summary>
    public class Msg_heartbeat : MavlinkMessage
    {
        public byte fightstatus;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_HEARTBEAT(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// ping
    /// </summary>
    public class Msg_ping : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number.
        /// </summary>
        public UInt64 time_usec;

        /// <summary>
        /// PING sequence
        /// </summary>
        public UInt32 seq;

        /// <summary>
        /// 0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system
        /// </summary>
        public byte target_system;

        /// <summary>
        /// 0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component.
        /// </summary>
        public byte target_component;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_PING(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// ContrlMode
    /// </summary>
    public class Msg_controlmode : MavlinkMessage
    {
        public byte contrlmode;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_CONTROLMODE(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// SpeedMode
    /// </summary>
    public class Msg_speedmode : MavlinkMessage
    {
        public byte speedmode;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_SPEEDMODE(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites.
    /// </summary>
    public class Msg_gps_status : MavlinkMessage
    {

        /// <summary>
        /// Number of satellites visible
        /// </summary>
        public byte satellites_visible;

        /// <summary>
        /// Global satellite ID
        /// </summary>
        public byte[] satellite_prn; // Array size 20

        /// <summary>
        /// 0: Satellite not used, 1: used for localization
        /// </summary>
        public byte[] satellite_used; // Array size 20

        /// <summary>
        /// Elevation (0: right on top of receiver, 90: on the horizon) of satellite
        /// </summary>
        public byte[] satellite_elevation; // Array size 20

        /// <summary>
        /// Direction of satellite, 0: 0 deg, 255: 360 deg.
        /// </summary>
        public byte[] satellite_azimuth; // Array size 20

        /// <summary>
        /// Signal to noise ratio of satellite
        /// </summary>
        public byte[] satellite_snr; // Array size 20

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_GPS_STATUS(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
    /// </summary>
    public class Msg_attitude : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;

        /// <summary>
        /// Roll angle (-pi..+pi)
        /// </summary>
        public float roll;

        /// <summary>
        /// Pitch angle (-pi..+pi)
        /// </summary>
        public float pitch;

        /// <summary>
        /// Yaw angle (-pi..+pi)
        /// </summary>
        public float yaw;

        /// <summary>
        /// Roll angular speed
        /// </summary>
        public float rollspeed;

        /// <summary>
        /// Pitch angular speed
        /// </summary>
        public float pitchspeed;

        /// <summary>
        /// Yaw angular speed
        /// </summary>
        public float yawspeed;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_ATTITUDE(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// attitudeext
    /// </summary>
    public class Msg_attitude_ext : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;
        public float Aacceleration_X;
        public float Aacceleration_Y;
        public float Aacceleration_Z;
        public float BarometricAltitude;
        public float MicroAltitude;
        public float Pressure;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_ATTITUDE_EXT(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// GPS
    /// </summary>
    public class Msg_global_position_int : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;

        /// <summary>
        /// Latitude, expressed
        /// </summary>
        public Int32 lat;

        /// <summary>
        /// Longitude, expressed
        /// </summary>
        public Int32 lon;

        /// <summary>
        /// Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL.
        /// </summary>
        public Int32 alt;

        /// <summary>
        /// Altitude above ground
        /// </summary>
        public Int32 relative_alt;

        /// <summary>
        /// Ground X Speed (Latitude, positive north)
        /// </summary>
        public Int16 vx;

        /// <summary>
        /// Ground Y Speed (Longitude, positive east)
        /// </summary>
        public Int16 vy;

        /// <summary>
        /// Ground Z Speed (Altitude, positive down)
        /// </summary>
        public Int16 vz;

        /// <summary>
        /// Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 hdg;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_GLOBAL_POSITION_INT(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// GPSExt
    /// </summary>
    public class Msg_global_position_int_ext : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;
        public Int32 GPSSpeed;
        public Int32 GPSYaw;
        public Int32 SatellitesCount;
        public Int32 PositionalAccuracy;
        public Int16 HorizontalAccuracy;
        public Int16 VerticalAccuracy;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_GLOBAL_POSITION_INT_EXT(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// FunctionStatus
    /// </summary>
    public class Msg_functionstatus : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;

        /// <summary>
        /// function name
        /// </summary>
        public byte[] functionname; // Array size 50

        /// <summary>
        /// function status
        /// </summary>
        public byte status;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_FUNCTIONSTATUS(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// SetFunctionStatus
    /// </summary>
    public class Msg_setfunctionstatus : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;

        /// <summary>
        /// function name
        /// </summary>
        public byte[] functionname; // Array size 50

        /// <summary>
        /// function status
        /// </summary>
        public byte status;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_SETFUNCTIONSTATUS(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// LOG
    /// </summary>
    public class Msg_log : MavlinkMessage
    {

        /// <summary>
        /// Timestamp (time since system boot).
        /// </summary>
        public UInt32 time_boot_ms;
        public byte logtype;
        public byte[] logtext; // Array size 200

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_LOG(this, bytes, ref offset);
        }
    }


    /// <summary>
    /// This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitly set by the operator before or after. The position the system will return to and land on. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
    /// </summary>
    public class Msg_home_position : MavlinkMessage
    {

        /// <summary>
        /// Latitude (WGS84)
        /// </summary>
        public Int32 latitude;

        /// <summary>
        /// Longitude (WGS84)
        /// </summary>
        public Int32 longitude;

        /// <summary>
        /// Altitude (MSL). Positive for up.
        /// </summary>
        public Int32 altitude;

        /// <summary>
        /// Local X position of this position in the local coordinate frame
        /// </summary>
        public float x;

        /// <summary>
        /// Local Y position of this position in the local coordinate frame
        /// </summary>
        public float y;

        /// <summary>
        /// Local Z position of this position in the local coordinate frame
        /// </summary>
        public float z;

        /// <summary>
        /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
        /// </summary>
        public float[] q; // Array size 4

        /// <summary>
        /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float approach_x;

        /// <summary>
        /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float approach_y;

        /// <summary>
        /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float approach_z;

        public override int Serialize(byte[] bytes, ref int offset)
        {
            return MavLinkSerializer.Serialize_HOME_POSITION(this, bytes, ref offset);
        }
    }

}

