/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: RasberryPiFCSMessage.xml

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;

    
using System.Reflection;    
    
//[assembly: AssemblyTitle("Mavlink Classes")]
//[assembly: AssemblyDescription("Generated Message Classes for Mavlink. See http://qgroundcontrol.org/mavlink/start")]
//[assembly: AssemblyProduct("Mavlink")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]

    namespace MavLink
{

}

    
   
namespace MavLink.Message
{

    public abstract class MavlinkMessage
    {
        public abstract int Serialize(byte[] bytes, ref int offset);
    }

	/// <summary>
	/// HeartBeat
	/// </summary>
	public class Msg_heartbeat : MavlinkMessage
    {
		public byte SysMessage;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_HeartBeat(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
	/// </summary>
	public class Msg_sys_status : MavlinkMessage
    {

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.
		/// </summary>
		public UInt32 onboard_control_sensors_present;

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.
		/// </summary>
		public UInt32 onboard_control_sensors_enabled;

		/// <summary>
		/// Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.
		/// </summary>
		public UInt32 onboard_control_sensors_health;

		/// <summary>
		/// Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000
		/// </summary>
		public UInt16 load;

		/// <summary>
		/// Battery voltage, UINT16_MAX: Voltage not sent by autopilot
		/// </summary>
		public UInt16 voltage_battery;

		/// <summary>
		/// Battery current, -1: Current not sent by autopilot
		/// </summary>
		public Int16 current_battery;

		/// <summary>
		/// Battery energy remaining, -1: Battery remaining energy not sent by autopilot
		/// </summary>
		public sbyte battery_remaining;

		/// <summary>
		/// Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
		/// </summary>
		public UInt16 drop_rate_comm;

		/// <summary>
		/// Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
		/// </summary>
		public UInt16 errors_comm;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count1;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count2;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count3;

		/// <summary>
		/// Autopilot-specific errors
		/// </summary>
		public UInt16 errors_count4;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_SYS_STATUS(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
	/// </summary>
	public class Msg_attitude : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// Roll angle (-pi..+pi)
		/// </summary>
		public float roll;

		/// <summary>
		/// Pitch angle (-pi..+pi)
		/// </summary>
		public float pitch;

		/// <summary>
		/// Yaw angle (-pi..+pi)
		/// </summary>
		public float yaw;

		/// <summary>
		/// Roll angular speed
		/// </summary>
		public float rollspeed;

		/// <summary>
		/// Pitch angular speed
		/// </summary>
		public float pitchspeed;

		/// <summary>
		/// Yaw angular speed
		/// </summary>
		public float yawspeed;

		/// <summary>
		/// x轴加速度
		/// </summary>
		public float Aacceleration_X;

		/// <summary>
		/// y轴加速度
		/// </summary>
		public float Aacceleration_Y;

		/// <summary>
		/// z轴加速度
		/// </summary>
		public float Aacceleration_Z;

		/// <summary>
		/// 气压高度
		/// </summary>
		public float BarometricAltitude;

		/// <summary>
		/// 气压
		/// </summary>
		public float Pressure;

		/// <summary>
		/// 超声波测高
		/// </summary>
		public float MicroAltitude;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_Attitude(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It
	///               is designed as scaled integer message since the resolution of float is not sufficient.
	/// </summary>
	public class Msg_gpsdata : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// 纬度
		/// </summary>
		public double Latitude;

		/// <summary>
		/// 经度
		/// </summary>
		public double Longitude;

		/// <summary>
		/// GPS高度
		/// </summary>
		public float GPSAltitude;

		/// <summary>
		/// GPS地速
		/// </summary>
		public float GPSSpeed;

		/// <summary>
		/// GPS航向
		/// </summary>
		public float GPSHeading;

		/// <summary>
		/// GPS偏航角
		/// </summary>
		public float GPSYaw;

		/// <summary>
		/// 卫星数量
		/// </summary>
		public Int16 SatellitesCount;

		/// <summary>
		/// 精度
		/// </summary>
		public float PositionalAccuracy;

		/// <summary>
		/// 水平精度
		/// </summary>
		public float HorizontalAccuracy;

		/// <summary>
		/// 垂直精度
		/// </summary>
		public float VerticalAccuracy;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_GPSData(this, bytes, ref offset);
            }        
	}


	/// <summary>
	/// 引擎数据
	/// </summary>
	public class Msg_enginedata : MavlinkMessage
    {

		/// <summary>
		/// Timestamp (time since system boot).
		/// </summary>
		public UInt32 time_boot_ms;

		/// <summary>
		/// 引擎1转速
		/// </summary>
		public Int16 Engine01_RPM;

		/// <summary>
		/// 引擎2转速
		/// </summary>
		public Int16 Engine02_RPM;

		/// <summary>
		/// 引擎3转速
		/// </summary>
		public Int16 Engine03_RPM;

		/// <summary>
		/// 引擎4转速
		/// </summary>
		public Int16 Engine04_RPM;

		/// <summary>
		/// 引擎1功率
		/// </summary>
		public float Engine01_Power;

		/// <summary>
		/// 引擎2功率
		/// </summary>
		public float Engine02_Power;

		/// <summary>
		/// 引擎3功率
		/// </summary>
		public float Engine03_Power;

		/// <summary>
		/// 引擎4功率
		/// </summary>
		public float Engine04_Power;

        public override int Serialize(byte[] bytes, ref int offset)
            {
                return MavLinkSerializer.Serialize_EngineData(this, bytes, ref offset);
            }        
	}

}

